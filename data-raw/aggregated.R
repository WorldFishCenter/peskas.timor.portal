library(magrittr)

#' Authenticate to a storage cloud provider
#'
#' Usually used internally by other functions
#'
#' @param provider cloud provider to use, either "gcs" or "aws"
#' @param options named list with cloud provider options, see details
#'
#' @details
#'
#' ### Google Cloud Services
#'
#' For Google Cloud Services ("gcs") options must be a list with the field
#' `service_account_key` with the contents of the authentication json file you
#' have downloaded from your Google Project.
#'
#' This function uses [googleCloudStorageR::gcs_auth] under the hood to
#' authenticate.
#'
#' @examples
#'
#' # Google Cloud Services
#' \dontrun{
#' authentication_details <- readLines("location_of_json_file.json")
#' cloud_storage_authenticate(
#'   provider = "gcs",
#'   options = list(
#'     service_account_key = authentication_details,
#'     bucket = "my-bucket"
#'   )
#' )
#' }
cloud_storage_authenticate <- function(provider, options) {
  if ("gcs" %in% provider) {
    # Only need to authenticate if there is no token for downstream requests
    if (isFALSE(googleAuthR::gar_has_token())) {
      service_account_key <- options$service_account_key
      temp_auth_file <- tempfile(fileext = "json")
      writeLines(service_account_key, temp_auth_file)
      googleCloudStorageR::gcs_auth(json_file = temp_auth_file)
    }
  }
}

#' Get the full name of a versioned cloud object
#'
#' Obtain the full name (e.g.
#' `timor-landings-v2_metadata__20210326084600_54617b3__.json`) of a cloud
#' storage object. If there are more than one object matching the prefix,
#' version, and extension, a vector with all the names is returned.
#'
#' @param prefix string indicating the prefix of the object
#' @param version either "latest" or the specific version string generated by
#'   [add_version] when the file was uploaded to the cloud provider
#' @param extension extension of the desired file. Use an empty string "" to
#'   return all extensions founds
#' @param provider
#' @param exact_match logical indicating whether the prefix should be matched
#'   exactly
#' @param options
#' @inheritParams upload_cloud_file
#'
#'
#' @details
#'
#' ### Google Cloud Services
#'
#' For Google Cloud Services ("gcs") options must be a list with two fields:
#' `bucket` with the bucketname (character) you are uploading to, and
#' `service_account_key` with the contents of the authentication json file you
#' have downloaded from your Google Project (if [cloud_storage_authenticate] has
#' not been called before).
#'
#' This function uses [googleCloudStorageR::gcs_upload] under the hood to upload
#' the file.
#'
#' @return A string vector with the object names in the cloud storage that match
#'   the prefix, the version, and the extension indicated in the parameters
#'
#' @examples
#'
#' #' # Google Cloud Services
#' \dontrun{
#' authentication_details <- readLines("location_of_json_file.json")
#' # obtain the latest version of all files corresponding to timor-landings-v2
#' cloud_object_name(
#'   prefix = "timor-landings-v2",
#'   version = "latest",
#'   provider = "gcs",
#'   options = list(
#'     service_account_key = authentication_details,
#'     bucket = "my-bucket"
#'   )
#' )
#'
#' # obtain a specific version of the structured data from timor-landings-v2
#' cloud_object_name(
#'   prefix = "timor-landings-v2_raw",
#'   version = "20210326084600_54617b",
#'   extension = "csv",
#'   provider = "gcs",
#'   options = list(
#'     service_account_key = authentication_details,
#'     bucket = "my-bucket"
#'   )
#' )
#' }
#'
cloud_object_name <- function(
  prefix,
  version = "latest",
  extension = "",
  provider,
  exact_match = FALSE,
  options
) {
  cloud_storage_authenticate(provider, options)

  if ("gcs" %in% provider) {
    gcs_files <- googleCloudStorageR::gcs_list_objects(
      bucket = options$bucket,
      prefix = prefix
    )

    if (nrow(gcs_files) == 0) {
      return(character(0))
    }

    gcs_files_formatted <- gcs_files %>%
      tidyr::separate(
        col = .data$name,
        into = c("base_name", "version", "ext"),
        # Version is separated with the "__" string
        sep = "__",
        remove = FALSE
      ) %>%
      dplyr::filter(stringr::str_detect(.data$ext, paste0(extension, "$"))) %>%
      dplyr::group_by(.data$base_name, .data$ext) %>%
      na.omit()

    if (isTRUE(exact_match)) {
      selected_rows <- gcs_files_formatted %>%
        dplyr::filter(.data$base_name == prefix)
    } else {
      selected_rows <- gcs_files_formatted
    }

    if (version == "latest") {
      selected_rows <- selected_rows %>%
        dplyr::filter(max(.data$updated) == .data$updated)
    } else {
      selected_rows <- selected_rows %>%
        dplyr::filter(.data$version == version)
    }

    selected_rows$name
  }
}


#' Download an object from a cloud storage bucket to a local file
#'
#' Download object from the cloud storage to a local file
#'
#' @param name the name of the object in the storage bucket.
#' @param provider
#' @param options
#' @param file a file-path (character) where the object will be saved. Default
#'   is the object name.
#' @inheritParams upload_cloud_file
#'
#'
#' @return the file path
#'
#' @examples
#'
#' # Google Cloud Services
#' \dontrun{
#' authentication_details <- readLines("location_of_json_file.json")
#' download_cloud_file(
#'   name = "timor-landings-v2_metadata__20210326084600_54617b3__.json",
#'   provider = "gcs",
#'   options = list(
#'     service_account_key = authentication_details,
#'     bucket = "my-bucket"
#'   )
#' )
#' }
download_cloud_file <- function(name, provider, options, file = name) {
  cloud_storage_authenticate(provider, options)

  if ("gcs" %in% provider) {
    purrr::map2(
      name,
      file,
      ~ googleCloudStorageR::gcs_get_object(
        object_name = .x,
        bucket = options$bucket,
        saveToDisk = .y,
        overwrite = ifelse(is.null(options$overwrite), TRUE, options$overwrite)
      )
    )
  }

  file
}

get_file <- function(prefix) {
  filename <- cloud_object_name(
    prefix = prefix,
    provider = pars$storage$google$key,
    extension = "rds",
    options = pars$storage$google$options,
    exact_match = TRUE
  )
  download_cloud_file(
    name = filename,
    provider = pars$storage$google$key,
    options = pars$storage$google$options
  )

  x <- readRDS(filename)
  file.remove(filename)
  date_modified <- strptime(
    strsplit(filename, "_")[[1]][4],
    format = "%Y%m%d%H%M"
  )

  attr(x, "data_last_updated") <- date_modified
  x
}

format_aggregated_data <- function(
  aggregated,
  municipal = FALSE,
  national_boats = NULL
) {
  if (isTRUE(municipal)) {
    aggregated <- data.table::as.data.table(aggregated)
    aggregated$month <- format(aggregated$date_bin_start, format = "%B %Y")
    aggregated$year <- format(aggregated$date_bin_start, format = "%Y")
  } else {
    aggregated <- lapply(aggregated, data.table::as.data.table)
    aggregated <- lapply(aggregated, function(x) x[, n_boats := national_boats])
    aggregated$day <- aggregated$day[,
      day := format(date_bin_start, format = "%d %b %y")
    ]
    aggregated$week <- aggregated$week[,
      week := format(date_bin_start, format = "%d %b %y")
    ]
    aggregated$month <- aggregated$month[,
      month := format(date_bin_start, format = "%B %Y")
    ][, year := format(date_bin_start, format = "%Y")]
    aggregated$year <- aggregated$year[,
      year := format(date_bin_start, format = "%Y")
    ]
  }
  aggregated
}

label_taxa_groups <- function(x) {
  label_groups <- data.table::data.table(
    taxa = x$catch_taxon,
    group = x$fish_group
  )
  label_groups <- label_groups[, .(taxa = unique(taxa)), by = "group"]
  label_groups_list <- split(as.list(label_groups$taxa), label_groups$group)
  label_groups_list
}

rename_ontology <- function(x) {
  names(x) <- gsub("catch_price", "revenue", names(x))
  names(x) <- gsub("municipality", "region", names(x))
  names(x) <- gsub("landing_catch", "landing_weight", names(x))
  names(x) <- gsub("catch_preservation", "conservation_place", names(x))
  names(x) <- gsub("gear", "gear_type", names(x))
  return(x)
}

# Download file
pars <- config::get(file = "inst/golem-config.yml")

aggregated <- get_file("timor_aggregated")
data_last_updated <- attr(aggregated, "data_last_updated")
aggregated <- aggregated %>% purrr::map(rename_ontology)
municipal_aggregated <- get_file("timor_municipal_aggregated") %>%
  rename_ontology()
taxa_aggregated <- get_file("timor_taxa_aggregated") %>%
  purrr::map(rename_ontology)
municipal_taxa <- get_file("timor_municipal_taxa") %>% rename_ontology()
nutrients_aggregated <- get_file("timor_nutrients_aggregated") %>%
  purrr::map(., ~ dplyr::filter(.x, !nutrient == "selenium"))
summary_data <- get_file("summary_data")

indicators_grid <- get_file("indicators_gridded") %>%
  data.table::as.data.table()
label_groups_list <- label_taxa_groups(indicators_grid)

boats <- sum(unique(municipal_aggregated$n_boats))

aggregated <- format_aggregated_data(aggregated, national_boats = boats)
municipal_aggregated <- format_aggregated_data(
  municipal_aggregated,
  municipal = TRUE
)
taxa_aggregated <- format_aggregated_data(
  taxa_aggregated,
  national_boats = boats
)
nutrients_aggregated <- format_aggregated_data(
  nutrients_aggregated,
  national_boats = boats
)
municipal_taxa <- format_aggregated_data(municipal_taxa, municipal = TRUE)

# download kepler map and move to www folder
kepler_map <- download_cloud_file(
  name = "kepler_pds_map.html",
  provider = pars$storage$google$key,
  options = pars$storage$google$options
)

destination_dir <- system.file("app/www", package = "peskas.timor.portal")
file.copy(kepler_map, destination_dir, overwrite = TRUE)
file.remove(kepler_map)

estimated_tons <-
  taxa_aggregated$month %>%
  dplyr::mutate(
    fish_group = dplyr::case_when(
      grouped_taxa %in% c("COZ") ~ "Molluscs",
      grouped_taxa %in% c("PEZ") ~ "Shrimps",
      grouped_taxa %in% c("MZZ") ~ "Other",
      grouped_taxa %in% c("SLV", "CRA") ~ "Crustaceans",
      grouped_taxa %in% c("OCZ", "IAX") ~ "Cephalopods",
      grouped_taxa %in% c("SKH", "SRX") ~ "Sharks and rays",
      grouped_taxa %in% c("SNA", "GPX", "PWT", "GRX", "MUI", "BGX") ~
        "Large demersals",
      grouped_taxa %in%
        c(
          "CGX",
          "TUN",
          "BEN",
          "LWX",
          "BAR",
          "SFA",
          "CBA",
          "DOX",
          "ECN",
          "DOS"
        ) ~
        "Large pelagics",
      grouped_taxa %in%
        c(
          "YDX",
          "SPI",
          "EMP",
          "SUR",
          "TRI",
          "MOJ",
          "WRA",
          "MOO",
          "BWH",
          "LGE",
          "MOB",
          "MHL",
          "GOX",
          "THO",
          "IHX",
          "APO",
          "IHX",
          "PUX",
          "DRZ"
        ) ~
        "Small demersals",
      grouped_taxa %in%
        c(
          "RAX",
          "SDX",
          "CJX",
          "CLP",
          "GZP",
          "FLY",
          "KYX",
          "CLP",
          "MUL",
          "DSF",
          "MIL",
          "THF"
        ) ~
        "Small pelagics",
      TRUE ~ NA_character_
    )
  ) %>%
  dplyr::group_by(.data$fish_group) %>%
  dplyr::summarise(tons = sum(.data$catch, na.rm = T) / 1000) %>%
  dplyr::mutate(tons = round(.data$tons, 0)) %>%
  dplyr::arrange(-.data$tons)

estimated_revenue <-
  municipal_aggregated %>%
  dplyr::mutate(
    Area = dplyr::case_when(
      .data$region %in%
        c("Oecusse", "Bobonaro", "Liquica", "Dili", "Manatuto", "Baucau") ~
        "North Coast",
      .data$region == "Atauro" ~ "Atauro island",
      TRUE ~ "South Coast"
    )
  ) %>%
  dplyr::group_by(.data$Area) %>%
  dplyr::summarise(`Estimated revenue` = sum(.data$revenue, na.rm = T)) %>%
  dplyr::mutate(`Estimated revenue` = round(`Estimated revenue`, 0))

summary_data <-
  list(
    n_surveys = summary_data$n_surveys,
    estimated_tons = estimated_tons,
    estimated_revenue = estimated_revenue,
    catch_habitat = summary_data$catch_norm,
    revenue_habitat = summary_data$catch_price_norm,
    nutrients_per_catch = summary_data$nutrients_per_catch,
    nutrients_habitat = summary_data$nutrients_norm,
    conservation = summary_data$conservation,
    region_cpue = summary_data$cpue_df,
    timor_boundaries = summary_data$timor_shape
  )

usethis::use_data(aggregated, overwrite = TRUE)
usethis::use_data(taxa_aggregated, overwrite = TRUE)
usethis::use_data(municipal_aggregated, overwrite = TRUE)
usethis::use_data(municipal_taxa, overwrite = TRUE)
usethis::use_data(nutrients_aggregated, overwrite = TRUE)
usethis::use_data(data_last_updated, overwrite = TRUE)
usethis::use_data(indicators_grid, overwrite = TRUE)
usethis::use_data(label_groups_list, overwrite = TRUE)
usethis::use_data(summary_data, overwrite = TRUE)
