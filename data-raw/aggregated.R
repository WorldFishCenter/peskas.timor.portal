library(magrittr)

#' Authenticate to a storage cloud provider
#'
#' Usually used internally by other functions
#'
#' @param provider cloud provider to use, either "gcs" or "aws"
#' @param options named list with cloud provider options, see details
#'
#' @details
#'
#' ### Google Cloud Services
#'
#' For Google Cloud Services ("gcs") options must be a list with the field
#' `service_account_key` with the contents of the authentication json file you
#' have downloaded from your Google Project.
#'
#' This function uses [googleCloudStorageR::gcs_auth] under the hood to
#' authenticate.
#'
#' @examples
#'
#'  # Google Cloud Services
#' \dontrun{
#'   authentication_details <- readLines("location_of_json_file.json")
#'   cloud_storage_authenticate(
#'     provider = "gcs",
#'     options = list(service_account_key = authentication_details,
#'                    bucket = "my-bucket"))
#' }
cloud_storage_authenticate <- function(provider, options) {

  if ("gcs" %in% provider) {
    # Only need to authenticate if there is no token for downstream requests
    if (isFALSE(googleAuthR::gar_has_token())) {
      service_account_key <- options$service_account_key
      temp_auth_file <- tempfile(fileext = 'json')
      writeLines(service_account_key,temp_auth_file)
      googleCloudStorageR::gcs_auth(json_file = temp_auth_file)
    }
  }
}

#' Get the full name of a versioned cloud object
#'
#' Obtain the full name (e.g.
#' `timor-landings-v2_metadata__20210326084600_54617b3__.json`) of a cloud
#' storage object. If there are more than one object matching the prefix,
#' version, and extension, a vector with all the names is returned.
#'
#' @param prefix string indicating the prefix of the object
#' @param version either "latest" or the specific version string generated by
#'   [add_version] when the file was uploaded to the cloud provider
#' @param extension extension of the desired file. Use an empty string "" to
#'   return all extensions founds
#' @param provider
#' @param exact_match logical indicating whether the prefix should be matched
#'   exactly
#' @param options
#' @inheritParams upload_cloud_file
#'
#'
#' @details
#'
#' ### Google Cloud Services
#'
#' For Google Cloud Services ("gcs") options must be a list with two fields:
#' `bucket` with the bucketname (character) you are uploading to, and
#' `service_account_key` with the contents of the authentication json file you
#' have downloaded from your Google Project (if [cloud_storage_authenticate] has
#' not been called before).
#'
#' This function uses [googleCloudStorageR::gcs_upload] under the hood to upload
#' the file.
#'
#' @return A string vector with the object names in the cloud storage that match
#'   the prefix, the version, and the extension indicated in the parameters
#'
#' @examples
#'
#' #' # Google Cloud Services
#' \dontrun{
#'   authentication_details <- readLines("location_of_json_file.json")
#'   # obtain the latest version of all files corresponding to timor-landings-v2
#'   cloud_object_name(
#'     prefix = "timor-landings-v2",
#'     version = "latest",
#'     provider = "gcs",
#'     options = list(service_account_key = authentication_details,
#'                    bucket = "my-bucket"))
#'
#'  # obtain a specific version of the structured data from timor-landings-v2
#'   cloud_object_name(
#'     prefix = "timor-landings-v2_raw",
#'     version = "20210326084600_54617b",
#'     extension = "csv",
#'     provider = "gcs",
#'     options = list(service_account_key = authentication_details,
#'                    bucket = "my-bucket"))
#' }
#'
cloud_object_name <- function(prefix, version = "latest", extension = "",
                              provider, exact_match = FALSE, options){

  cloud_storage_authenticate(provider, options)

  if ("gcs" %in% provider) {

    gcs_files <- googleCloudStorageR::gcs_list_objects(
      bucket = options$bucket,
      prefix = prefix)

    if (nrow(gcs_files) == 0) {
      return(character(0))
    }

    gcs_files_formatted <- gcs_files %>%
      tidyr::separate(col = .data$name,
                      into = c("base_name", "version", "ext"),
                      # Version is separated with the "__" string
                      sep = "__",
                      remove = FALSE) %>%
      dplyr::filter(stringr::str_detect(.data$ext, paste0(extension, "$"))) %>%
      dplyr::group_by(.data$base_name, .data$ext)

    if (isTRUE(exact_match)) {
      selected_rows <- gcs_files_formatted %>%
        dplyr::filter(.data$base_name == prefix)
    } else {
      selected_rows <- gcs_files_formatted
    }

    if (version == "latest") {
      selected_rows <- selected_rows %>%
        dplyr::filter(max(.data$updated) == .data$updated)

    } else {
      selected_rows <- selected_rows %>%
        dplyr::filter(.data$version == version)

    }

    selected_rows$name
  }
}


#' Download an object from a cloud storage bucket to a local file
#'
#' Download object from the cloud storage to a local file
#'
#' @param name the name of the object in the storage bucket.
#' @param provider
#' @param options
#' @param file a file-path (character) where the object will be saved. Default
#'   is the object name.
#' @inheritParams upload_cloud_file
#'
#'
#' @return the file path
#'
#' @examples
#'
#' # Google Cloud Services
#' \dontrun{
#'   authentication_details <- readLines("location_of_json_file.json")
#'   download_cloud_file(
#'     name = "timor-landings-v2_metadata__20210326084600_54617b3__.json",
#'     provider = "gcs",
#'     options = list(service_account_key = authentication_details,
#'                    bucket = "my-bucket"))
#' }
download_cloud_file <- function(name, provider, options, file = name){

  cloud_storage_authenticate(provider, options)

  if ("gcs" %in% provider) {

    purrr::map2(
      name, file,
      ~ googleCloudStorageR::gcs_get_object(
        object_name = .x,
        bucket = options$bucket,
        saveToDisk = .y,
        overwrite = ifelse(is.null(options$overwrite), TRUE, options$overwrite)
      )
    )

  }

  file
}

get_file <- function(prefix){
  filename <- cloud_object_name(
    prefix = prefix,
    provider = pars$storage$google$key,
    extension = "rds",
    options = pars$storage$google$options,
    exact_match = TRUE)
  download_cloud_file(name = filename,
                      provider = pars$storage$google$key,
                      options = pars$storage$google$options)

  x <- readRDS(filename)
  file.remove(filename)
  date_modified <- strptime(strsplit(filename, "_")[[1]][4], format = "%Y%m%d%H%M")

  attr(x, "data_last_updated") <- date_modified
  x
}

format_aggregated_data <- function(aggregated, municipal = FALSE){
  if(isTRUE(municipal)){
    aggregated <- data.table::as.data.table(aggregated)
    aggregated$month <- format(aggregated$date_bin_start, format = "%B %Y")
    aggregated$year <- format(aggregated$date_bin_start, format = "%Y")
  } else {
  aggregated <- lapply(aggregated, data.table::as.data.table)
  aggregated <- lapply(aggregated, function(x) x[, n_boats := 2334])
  aggregated$day <- aggregated$day[, day := format(date_bin_start, format = "%d %b %y")]
  aggregated$week <- aggregated$week[, week := format(date_bin_start, format = "%d %b %y")]
  aggregated$month <- aggregated$month[, month := format(date_bin_start, format = "%B %Y")][, year := format(date_bin_start, format = "%Y")]
  aggregated$year <- aggregated$year[, year := format(date_bin_start, format = "%Y")]
  }
  aggregated
}

label_taxa_groups <- function(x) {
  label_groups <- data.table::data.table(
    taxa = x$catch_taxon,
    group = x$fish_group
  )
  label_groups <- label_groups[, .(taxa = unique(taxa)), by = "group"]
  label_groups_list <- split(as.list(label_groups$taxa), label_groups$group)
  label_groups_list
}

# Download file
pars <- config::get(file = "inst/golem-config.yml")

aggregated <- get_file("timor_aggregated")
municipal_aggregated <- get_file("timor_municipal_aggregated") %>%
  dplyr::mutate(revenue = ifelse(revenue == 0, NA_real_, .data$revenue))


taxa_aggregated <- get_file("timor_taxa_aggregated")
municipal_taxa <- get_file("timor_municipal_taxa")
nutrients_aggregated <- get_file("timor_nutrients_aggregated")

indicators_grid <- get_file("indicators_gridded") %>% data.table::as.data.table()
label_groups_list <- label_taxa_groups(indicators_grid)

data_last_updated <- attr(aggregated, "data_last_updated")
aggregated <- format_aggregated_data(aggregated)
municipal_aggregated <- format_aggregated_data(municipal_aggregated, municipal = TRUE)
taxa_aggregated <- format_aggregated_data(taxa_aggregated)
nutrients_aggregated <- format_aggregated_data(nutrients_aggregated)


usethis::use_data(aggregated, overwrite = TRUE)
usethis::use_data(taxa_aggregated, overwrite = TRUE)
usethis::use_data(municipal_aggregated, overwrite = TRUE)
#usethis::use_data(municipal_taxa, overwrite = TRUE)
usethis::use_data(nutrients_aggregated, overwrite = TRUE)
usethis::use_data(data_last_updated, overwrite = TRUE)
usethis::use_data(indicators_grid, overwrite = TRUE)
usethis::use_data(label_groups_list, overwrite = TRUE)

